from collections import defaultdict
from datetime import datetime

import pandas as pd
from tqdm.notebook import tqdm

from utils.apis import get_movie_cover
from utils.connection import open_connection, close_connection, get_db_name
from utils.fakes import generate_user, generate_reviews


def get_movies_and_troupe(data) -> tuple[list, list]:
    movies = []
    troupe = {}

    # Convert the DataFrame rows to a list of tuples
    data_list = list(data.iterrows())

    for idx, movieRow in tqdm(data_list, desc="Collecting movie entries...", total=len(data_list)):
        movie = {}
        if idx == 100:
            break

        movie["title"] = movieRow["title"]
        movie["tagline"] = movieRow["tagline"]
        movie["release_date"] = datetime.strptime(movieRow["release_date"], "%Y-%m-%d").isoformat()
        movie["release_year"] = movieRow["release_year"]
        movie["overview"] = movieRow["overview"]
        movie["runtime"] = movieRow["runtime"]
        movie["budget"] = movieRow["budget"]
        movie["revenue"] = movieRow["revenue"]
        movie["popularity"] = movieRow["popularity"]
        movie["poster"] = get_movie_cover(imdb_id=movieRow["imdb_id"])
        movie["genres"] = movieRow["genres"].split(", ")
        movie["production_companies"] = movieRow["production_companies"].split(", ")
        movie["production_countries"] = movieRow["production_countries"].split(", ")
        movie["spoken_languages"] = movieRow["spoken_languages"].split(", ")

        for column in ["cast", "director"]:
            members = []

            for member in movieRow[column].split(", "):
                members.append({
                    "full_name": member,
                })
                troupe_movie = {
                    "title": movieRow["title"],
                    "poster": movie["poster"],
                    "release_year": movieRow["release_year"],
                }
                if member not in troupe:
                    troupe[member] = {
                        "type": "actor" if column == "cast" else "director",
                        "movies": [troupe_movie]}
                else:
                    troupe[member]["movies"].append(troupe_movie)

            movie["actors" if column == "cast" else "directors"] = members

        # add the reviews field --> SUBSET PATTERN
        movie["reviews"] = []
        movie["watched_count"] = 0
        movie["added_count"] = 0

        movies.append(movie)

    troupe_data = []

    for full_name, data in troupe.items():
        troupe_data.append({
            "full_name": full_name,
            "type": data["type"],
            "movies": data["movies"],
            "picture": "https://media-cldnry.s-nbcnews.com/image/upload/t_fit-760w,f_auto,q_auto:best/rockcms/2023-09/kevin-james-king-of-queens-zz-230927-368fe6.jpg"
        })

    return movies, troupe_data


def update_coll_with_ids(data, ids):
    """
    This function updates a list of data dictionaries with the ObjectIds generated by MongoDB after insertion.

    Args:
        data: The list of data dictionaries.
        ids: The InsertManyResult object containing the inserted document IDs.

    Returns:
        The updated list of data dictionaries with the '_id' field added.
    """
    for d, inserted_id in zip(data, ids.inserted_ids):
        d["_id"] = inserted_id  # Directly assign ObjectId to movie
    return data


def pre_process_data(data_path: str) -> pd.DataFrame:
    # read the data from the csv file
    data = pd.read_csv(data_path)

    # drop the duplicates
    data = data.drop_duplicates(subset=["id"])
    data = data.drop(columns=["writers", "producers", "music_composer", "director_of_photography"])
    # remove rows with NA values
    clean_data = data.dropna()
    # add release_year
    clean_data.loc[:, 'release_year'] = clean_data['release_date'].str.slice(0, 4)
    # convert 'release_year' to numeric type if needed
    clean_data.loc[:, 'release_year'] = pd.to_numeric(clean_data['release_year'], errors='coerce', downcast='integer')
    # consider only the movies released in the last 30 years
    clean_data = clean_data.loc[(clean_data['release_year'] >= 1995) & (clean_data['release_year'] <= 2025)]
    clean_data.reset_index(drop=True, inplace=True)

    # return the preprocessed data
    return clean_data


def update_troup_data_with_movie_ids(troupe_data, movies):
    # Create a lookup dictionary from the first list for quick access
    lookup = {(movie['title'], movie['release_year']): movie['_id'] for movie in movies}

    # Iterate over the second list and transfer the _id if a match is found
    for troupe in troupe_data:
        for movie in troupe['movies']:
            key = (movie['title'], movie['release_year'])
            if key in lookup:
                movie['_id'] = lookup[key]

    return troupe_data


def main():
    client = open_connection()
    db_name = get_db_name()
    if db_name is None:
        raise ValueError("DB_NAME is not set in .env file")

    # this should predispose the creation of a database in MongoDB
    # the actual creation will be postponed until data is inserted
    db = getattr(client, db_name)

    # MOVIE - RATING: SUBSET DESIGN PATTERN source:
    # https://www.mongodb.com/blog/post/building-with-patterns-the-subset-pattern for the movie and rating
    # collections, we will use the subset design pattern the subset design pattern is a design pattern that allows us
    # to store a subset of the data in a collection in this case, we store the 5 most recent ratings for each movie
    # in the Movie collection and all the ratings in the Rating collection

    # USER - MOVIE: SUBSET DESIGN PATTERN
    # we will use the subset design pattern for the user's watchlist

    # RATING - USER: EXTENDED REFERENCE DESIGN PATTERN source:
    # https://www.mongodb.com/blog/post/building-with-patterns-the-extended-reference-pattern for the rating and user
    # collections, we will use the extended reference design pattern instead of embedding the user data in the rating
    # document, or use the id of the user to perform a join operation, we will store the embed the most accessed user
    # data in the rating document and perform join operations only when needed

    # create Movie collection
    movie_coll = db["movie"]
    # create Rating collection
    review_coll = db["review"]
    # create Troupe collection
    troupe_coll = db["troupe"]

    # create User collection. The validation schema ensures that each user document will have the same
    # structure
    if "user" not in db.list_collection_names():
        user_coll = db.create_collection("user", validator={
            "$jsonSchema": {
                "bsonType": "object",
                "required": ["username", "email", "password"],
                "properties": {
                    "_id": {  # allows the insertion of other documents
                        "bsonType": "objectId"
                    },
                    "username": {
                        "bsonType": "string",
                        "maxLength": 20,
                        "description": "'username' must be a string and is required. Max 20 characters"
                    },
                    "email": {
                        "bsonType": "string",
                        "pattern": "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$",
                        "description": "'email' must be a string and match the regular expression pattern"
                    },
                    "password": {
                        "bsonType": "string",
                        "minLength": 8,
                        "maxLength": 16,
                        "description": "'password' must be a string of at least 8 characters and maximum 16 characters,"
                                       "and is required"
                    },
                    "movies_list": {
                        "bsonType": "array",
                        "description": "'movies_list' must be an array of movie objects",
                        "items": {
                            "bsonType": "object",
                            "required": ["title", "watched"],
                            "properties": {
                                "_id": {  # allows the insertion of other documents
                                    "bsonType": "objectId"
                                },
                                "title": {
                                    "bsonType": "string",
                                    "description": "'movieTitle' must be a string and is required"
                                },
                                "poster": {
                                    "bsonType": ["string", "null"],
                                    "maxLength": 2048,
                                    "description": "'poster' is the url of the movie poster"
                                },
                                "watched": {
                                    "bsonType": "bool",
                                    "description": "'watched' must be a boolean and is required"
                                }
                            }
                        }
                    }
                }
            }
        })
    else:
        user_coll = db["user"]

    data = pre_process_data("TMDB_all_movies.csv")
    movies, troupe_data = get_movies_and_troupe(data)
    movies_ids = movie_coll.insert_many(movies)
    update_coll_with_ids(movies, movies_ids)

    # update troupe data with movie ids
    update_troup_data_with_movie_ids(troupe_data=troupe_data, movies=movies)

    users = generate_user(movies=movies)

    if len(movies_ids.inserted_ids) == 0:
        close_connection(client)
        raise ValueError("No movies were inserted")

    troupe_ids = troupe_coll.insert_many(troupe_data)

    if troupe_ids.inserted_ids == 0:
        movie_coll.delete_many({})
        close_connection(client)
        raise ValueError("No troupe data was inserted")

    users_ids = user_coll.insert_many(users)

    if users_ids.inserted_ids == 0:
        troupe_coll.delete_many({})
        movie_coll.delete_many({})
        close_connection(client)
        raise ValueError("No user was inserted")
    else:
        for movie in movies:
            movie_coll.update_one({"_id": movie["_id"]}, {"$set": {"added_count": movie["added_count"],
                                                                   "watched_count": movie["watched_count"]}})

    update_coll_with_ids(users, users_ids)

    reviews = generate_reviews(movies=movies, users=[{"_id": user["_id"], "username": user["username"]}
                                                     for user in users])
    review_ids = review_coll.insert_many(reviews)

    if review_ids.inserted_ids == 0:
        user_coll.delete_many({})
        troupe_coll.delete_many({})
        movie_coll.delete_many({})
        close_connection(client)
        raise ValueError("No review was inserted")
    else:
        # update movies with review array
        movies_with_reviews = []

        for movie in movies:
            if movie["reviews"] and len(movie["reviews"]) > 0:
                movies_with_reviews.append(movie)

        for movie in movies_with_reviews:
            movie_coll.update_one({"_id": movie["_id"]}, {"$set": {"reviews": movie["reviews"],
                                                                   "vote_count": movie["vote_count"],
                                                                   "vote_average": movie["vote_average"]}})

    print(f"Inserted {len(movies_ids.inserted_ids)} movies\nInserted {len(troupe_ids.inserted_ids)} troupe data\n" +
          f"Inserted {len(users_ids.inserted_ids)} users\nInserted {len(review_ids.inserted_ids)} reviews")
    close_connection(client)


if __name__ == "__main__":
    main()
